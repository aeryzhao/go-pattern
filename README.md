> 参考自[《设计模式》](https://refactoringguru.cn/design-patterns)，[dunwu的博客](https://dunwu.github.io/design)

## 常见的UML类图表达 

|连接点\连接线| 实线| 虚线|
|---|---|---|
|空心箭头|继承|实现接口|
|实线箭头|关联|依赖|

|-\连接点|空心|实心|
|---|---|---|
|菱形实线箭头|聚合|组合|

![UML类图示例](./assets/UML类图示例.png)
## 面向对象原则
### 单一职责原则
单一职责原则（Single Responsibility Principle），应该有且仅有一个原因引起类的变更。

简单点说，一个类，最好只负责一件事。

### 开放-封闭原则
开放-封闭原则（Open Close Principle），软件实体（类、模块、函数）等应该可以扩展，但是不可修改。

对于扩展是开放的；对于更改是封闭的。

### 里氏替换原则
里氏替换原则（Liskov Substitution Principle），子类可以替换父类。

### 依赖倒置原则
依赖倒置原则（Dependency Inversion Principle），抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。

关键点：

高层模块不应该依赖低层模块，两者都应该依赖其抽象
抽象不应该依赖细节
细节应该依赖抽象
#接口隔离原则
接口隔离原则（Interface Segregation Principle）使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。

客户端不应依赖它不需要的接口
类间的依赖关系应该建立在最小的接口上
### 迪米特原则
迪米特原则（Least Knowledge Principle）又称最少知识原则，一个软件实体应当尽可能少地与其他实体发生相互作用。

一个类应该对自己需要调用的类知道得最少，类的内部如何实现、如何复杂都与调用者或者依赖者没关系，调用者或者依赖者只需要知道他需要的方法即可，其他的我一概不关心。

## 设计模式
### 创建型模式
创建型模式提供了创建对象的机制，抽象了`实例化`的过程， 能够提升已有代码的灵活性和可复用性。  
创建型模式的`指导思想`是：
- 将系统使用的具体类封装起来。
- 隐藏这些具体类的实例创建和结合的方式。
#### 工厂方法模式（factory method）
![工厂方法](./assets/factory.png)
在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。
#### 抽象工厂模式（abstract factory）
 ![抽象工厂](./assets/absfactory.png)
提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。
 #### 生成器模式（builder）
![](./assets/builder.png)
分步骤创建复杂对象，通过不同的生成器快速创建不同的对象。
#### 原型模式（prototype）
![原型模式](./assets/prototype.png) 
为所有支持克隆的对象声明了一个通用接口，让你能够克隆对象，同时又无需将代码和对象所属类耦合。    
#### 单例模式 （single）
![单例模式](./assets/single.png)
保证一个类只有一个实例，并提供一个访问它的全局访问点。

### 结构型模式
#### 适配器模式（adapter）
![适配器模式](./assets/adapter.png)
让不兼容的接口能够互相合作。
#### 桥接模式（bridge）
![桥接模式](./assets/bridge.png)
将一个大类拆分为抽象部分与实现部分分离，使它们都可以独立的变化。
#### 组合模式 （component）
![组合模式](./assets/component.png)
将部分-整体的层次结构应用到对象中，使得用户对单个对象和组合对象的使用具有一致性。
#### 装饰模式（decorator）
![装饰模式](./assets/decorator.png)
动态的给一个对象添加一些额外的职责。
#### 外观模式（facade）
![外观模式](./assets/facade.png)
从复杂子系统中抽离出简单接口。
#### 享元模式（flyweight）
![享元模式](./assets/flyweight.png)
通过共享技术有效的支持大量细粒度的对象，避免创建很多重复对象。
#### 代理模式 （proxy）
![代理模式](./assets/proxy.png)
为其他对象提供一种代理以控制对这个对象的访问。

### 行为型模式
#### 策略模式（strategy）
![策略模式](./assets/strategy.png)
可以定义一系列算法，分别导入到不同的类中，已使不同的算法能够，使得相同的行为可以有不同的实现方式。
#### 责任链模式（chain of responsibility）
![责任链模式](./assets/chain.png)
收到请求后，可以选择处理或者转发给下一个处理者，并沿着这条链传递改请求，直到有一个对象处理它为止。
#### 命令模式（command）
![命令模式](./assets/command.png)




